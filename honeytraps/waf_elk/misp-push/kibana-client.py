#!.venv/bin/python3
# -*- coding: utf-8 -*-
from datetime import datetime, timedelta, timezone
from elasticsearch_async import AsyncElasticsearch
#from elasticsearch import Elasticsearch, TransportError
from urllib3.exceptions import ConnectTimeoutError
import json
import sys
import asyncio
import httpx
import time
import os
import logging
from typing import Callable, Any
from pymisp import PyMISP, PyMISPError
import requests

def unixTimeStamp(dt):
    return dt.isoformat()
    #return dt.replace(tzinfo=timezone.utc).timestamp()

class MispEvent(object):
    '''MISP event object on MISP'''

    ##Event consists of distribution, information, analysis and threat
    # The distribution setting used for the attributes and for the newly created event, if relevant. [0-3].
    distrib = 0

    # Used to populate the event info field if no event ID supplied.
    info = 'This is event generated from PyMISP'

    # The analysis level of the newly created event, if applicable. [0-2]
    analysis = 0

    # The threat level ID of the newly created event, if applicable. [1-4]
    threat = 1

    """docstring for MispEvent"""
    def __init__(self, distribution,info,analysis,threat):
        super(MispEvent, self).__init__()
        self.distrib = distribution
        self.info = info
        self.analysis = analysis
        self.threat = threat

class MispConnector(): # TODO: Switch to ExpandedPyMISP
    misp = None
    tagsGenerated = False
    def __init__(self, url, apiKey):
        self.misp = PyMISP(url, apiKey, MISP_VERIFYCERT, 'json', debug=False)
        self.generate_misp_tags
        log.info("MISP tags generated")

    def generate_misp_tags(self) -> bool:
        try:
            self.misp.new_tag(name='AutoGenerated', colour='#00ace6', exportable=True)
            self.misp.new_tag(name='HoneytrapEvent', colour='#581845', exportable=True)
            self.misp.new_tag(name='ModSecurity', colour='#a04000', exportable=True)
            return True
        except PyMISPError as e:
            log.warning("could not connect to MISP")
            return False

    def send_misp_event(self, misp_event):
        try:
            event = self.misp.new_event(misp_event.distrib, misp_event.threat, misp_event.analysis, misp_event.info)
            self.misp.add_tag(event, 'AutoGenerated', attribute=False)
            self.misp.add_tag(event, 'HoneytrapEvent', attribute=False)
            self.misp.add_tag(event, 'ModSecurity', attribute=False)
            log.debug(event)
        except PyMISPError as e:
            log.warning("could not connect to MISP")
            return False

    def generate_event_info(self, json_log):
        attacker_ip_address = json.dumps(json_log['_source']['transaction']['remote_address'])
        transaction_time = json.dumps(json_log['_source']['transaction']['time'])
        audit_data = json.dumps(json_log['_source']['messages'])
        audit_data_producer = json.dumps(json_log['_source']['audit_data']['producer'])

        event_info = "Attack identified from the "+attacker_ip_address+" at timestamp "+transaction_time+"  "+audit_data+" This information is generated from "+audit_data_producer
        return event_info

    def generate_event(self, json_log):
        misp_event_info = self.generate_event_info(json_log)
        return MispEvent(0,misp_event_info,0,1)


class ElasticConnector():
    es = None
    index = None
    httpClient = httpx.AsyncClient()

    def __init__(self):
        pass

    async def set_index(self, index: str) -> None:
        index_name = ""
        indexes = await self.es.indices.get(index)
        for index in indexes:
            log.debug("Index is " + str(index))
            index_str = str(index) 
            if index_str.find("filebeat-") != -1:
                log.debug("found it!")
                #log.debug(index_str)
                index_name = index_str
                #break
        self.index = index_name

    async def wait_until_up(self) -> None:
        while (True):
            log.info("Waiting for Elasticsearch to be Up...")
            try:
                res = await self.httpClient.get('http://elasticsearch:9200')
                self.es = AsyncElasticsearch([{'host': 'elasticsearch', 'port': 9200}])
                log.info("Elasticsearch is up")
                break
            except Exception as e:
                await asyncio.sleep(1)

    async def search(self, start: datetime, end: datetime) -> bool:
        return await self.es.search(index=self.index,body={'query':{'range':{'@timestamp':{'gte':unixTimeStamp(start),'lt':'now'}}}})

class Watcher():
    dataUploaded = None
    WATCH_INTERVAL = 10
    elastic = None
    misp = None

    def __init__(self):
        self.lastSearched = datetime.now() - timedelta(seconds=10)

    async def run(self):
        self.elastic = ElasticConnector()
        await self.elastic.wait_until_up()
        await self.elastic.set_index("filebeat-*")
        self.misp = MispConnector(MISP_URL, MISP_KEY)
        while(True):
            try:
                res = await self.queryElastic()
                log.debug('Got %d Hits:' % res['hits']['total']['value'])
                self.sendEvents(res)
                self.lastSearched = datetime.now()
            except PyMISPError as e:
                log.warning("Failed to connect to MISP, error: " + str(e))
            except ConnectTimeoutError as e:
                log.warning("Failed querying ElasticSearch, error: " + str(e))
            except  ConnectionRefusedError as e:
                log.warning("Transaction failed, error: " + str(e))
            except ConnectionError as e:
                log.warning("Connection error: " + str(e))
            except Exception as e:
                log.error("Unknown error: " + str(e))
            await asyncio.sleep(self.WATCH_INTERVAL)

    async def queryElastic(self):
        return await self.elastic.search(self.lastSearched, datetime.now())   

    def sendEvents(self, results):
        for event in results['hits']['hits']:
            log.debug('Index is ' + event['_index'])
            misp_event_obj = self.misp.generate_event(event)
            log.debug('=====================================================')
            self.misp.send_misp_event(misp_event_obj)
            log.info("New Events sent to MISP")


if __name__ == "__main__":
    # Setting up logging
    logging.basicConfig(level=logging.INFO, format='[%(asctime)s][%(levelname)s][%(name)s] %(message)s')
    stdOut = logging.StreamHandler(sys.stdout)
    log = logging.getLogger("MispConnector")
    handler = logging.FileHandler('/var/log/misp-connector.log')
    handler.setLevel(logging.INFO)
    # create a logging format
    formatter = logging.Formatter('[%(asctime)s][%(levelname)s][%(name)s] %(message)s')
    handler.setFormatter(formatter)
    log.addHandler(handler)

    MISP_URL = os.getenv("URL_MISP", None)
    MISP_KEY = os.getenv("MISP_KEY", None)
    MISP_VERIFYCERT = True if (os.getenv("MISP_VERIFYCERT", None) == "true") else False

    if (MISP_URL is None):
        log.critical("MISP_URL was not set in env file, exiting")
        exit

    watcher = Watcher()
    loop = asyncio.get_event_loop()
    loop.run_until_complete(watcher.run())
    loop.close()
        